<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Source: /vagrant/var/www/repo/EventPriorityEmitter/PrioritizedSubPub.js</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jaguar.css">
    
    
    <script>
    var config = {"monospaceLinks":false,"cleverLinks":false,"applicationName":"PrioritizedSubPub","linenums":true,"default":{"outputSourceFiles":true}};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">PrioritizedSubPub</a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentations">
    </div>
    <ul class="list">
    
        <li class="item" data-name="PrioritizedPubSub">
            <span class="title">
                <a href="global.html">PrioritizedPubSub</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="PrioritizedPubSub.getEventProxy"><a href="global.html#.getEventProxy">getEventProxy</a></li>
            
                <li data-name="PrioritizedPubSub.getEventPubCallback"><a href="global.html#.getEventPubCallback">getEventPubCallback</a></li>
            
                <li data-name="PrioritizedPubSub.pub"><a href="global.html#.pub">pub</a></li>
            
                <li data-name="PrioritizedPubSub.sub"><a href="global.html#.sub">sub</a></li>
            
                <li data-name="PrioritizedPubSub.unSub"><a href="global.html#.unSub">unSub</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
    </ul>
</div>
    <div class="main">
        <h1 class="page-title" data-filename="-_vagrant_var_www_repo_EventPriorityEmitter_PrioritizedSubPub.js.html">Source: /vagrant/var/www/repo/EventPriorityEmitter/PrioritizedSubPub.js</h1>
        


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * PrioritizedPubSub
 *
 *
 * @class PrioritizedPubSub
 *
 * @param   {String}                                subNameSpace    Name of new PrioritizedPubSub
 *
 * @returns {PSPProxy}                              `PSPProxy` is returned when `new` is used. It's has the same
 *                                                  behavior and signatures as PrioritizedPubSub but can only be used
 *                                                  if saved to a variable.
 */

/**
 * @function PrioritizedPubSub
 *
 * @static
 *
 * @param   {eventName}                                 eventName
 *
 * @param   {pspOptions|subscriptionCallback|function}  [options]
 *
 * @return {PrioritizedPubSub}
 */

/**
 * Object passed to PrioritizedPubSub.
 *
 * @typedef {Object} pspOptions
 *
 * @property {subscriptionCallback}     sub       Required for subscribing to an event. See {@link subscriptionCallback}
 *                                                This option has the highest precedence.
 *                                                Can be combined with {@link subscriptionOptions}
 *
 * @property {subscriptionId}           unSub     Required for un-subscribing an event. If set, pspOptions.pub will be ignored
 *
 * @property {pubArgs}                  pub       Required for publishing to subscribers. All other options have higher precedence.
 */

/**
 * Object of arguments passed to PrioritizedPubSub.pub or PrioritizedPubSub
 * for {@link subscriptionCallback} to use.
 *
 * @typedef {Object} pubArgs
 */

/**
 * Event name used for subscribing/publishing to.
 *
 * @typedef {String} eventName
 */

/**
 * User-defined id for identifying and removing from priority list. Randomly generated if not defined when
 * subscribing.
 *
 * @typedef {String} subscriptionId
 */

/**
 * All the options can be passed to PrioritizedPubSub and PrioritizedPubSub.sub
 *
 * @typedef {Object} subscriptionOptions
 *
 * @property {Integer}                  [unSubCount]    Will subscribe to however many times set. When it reaches the
 *                                                      limit, it will un-subscribe itself. Decrementing can be bypassed.
 *                                                      See {@link pspObj}
 *
 * @property {Boolean}                  [rePub=false]   If set to true and subscribing to an event and the event had
 *                                                      published in the past, then re-publish for this subscriber
 *                                                      using the previously publish data.
 *
 * @property {String}                   [subId]         {@link subscriptionId}
 *
 * @property {Number}                   [priority=0]    Can be any number type, excluding `NaN`.
 *                                                      Every subscription will append to the list of priorities,
 *                                                      except for subscriptionOptions.timing="def" since there
 *                                                      can be only one default.
 *                                                      If subscribing and options.priority is not set, 0 is used.
 *                                                      This option is ignored when subscriptionOptions.timing="def".
 *
 * @property {String}                   [timing='pre']  See {@link subscriptionTimings}
 *
 * @property {*}                        [context]       Specify the context of `this`
 */

/**
 * When the priority should happen. If not set during subscribing, pre will be used.
 *
 * pre : Before default timing. There can be many of these timings.
 *
 * def : Default publish event. There is only one default timing.
 *
 * post :After default event. There can be many of these timings.
 *
 * @typedef {String} subscriptionTimings
 */

/**
 * Object passed to {@link subscriptionCallback} as a second parameter.
 *
 * @typedef {Object}  pspObj
 *
 * @property {Object} CONST
 *
 * @property {String} CONST.SKIP_DEC        Prevent the subscriptionOptions.unSubCount from decrementing by
 *                                          returning from {@link subscriptionCallback}
 *
 * @property {String} CONST.UNSUB           Used to un-subscribe by returning from (@link subscriptionCallback}.
 */

/**
 * Callback used for subscriptions.
 *
 * @callback subscriptionCallback
 *
 * @param {pubArgs} args
 *
 * @param {pspObj}  pspObj
 */

(function (root, factory) {
    'use strict';
    /* global define, module */
    var ns = 'PrioritizedSubPub';
    //boilerplate node and browser defining.
    if (typeof define === 'function' &amp;&amp; define.amd) {
        define(ns, factory(root));
    } else if (
        typeof module === 'object'
        &amp;&amp; typeof module.exports === 'object'
    ) {
        module.exports = factory(root);
    } else {
        root[ns] = factory(root);
    }

}(this, function (global) {
    'use strict';

    var PRIORITY_TYPE = ['pre', 'def', 'post']
        , UNSUB = 'unsub'
        , SKIP_DEC = 'skip_dec'
        , util
    //host global usage for PSP
        , _globalPSP
        ;

    /* jshint ignore: start */
    if ((_globalPSP = typeof _)
        &amp;&amp; _globalPSP === 'function'
    ) {
        util = _;
    }
    /* jshint ignore: end */

    if (typeof util === 'undefined') {
        //Mini lodash/underscore
        util = {
            isUndefined: function (value) {
                return typeof value === 'undefined';
            }
            , isObject: function (value) {
                return value &amp;&amp; typeof value === 'object';
            }
            , isString: function (value) {
                return typeof value === 'string';
            }
            , isFunction: function (value) {
                return typeof value === 'function';
            }
            , toArray: function (args) {
                return Array.prototype.slice.call(args);
            }
            , indexOf: function (arr, val) {
                if (arr.indexOf) {
                    return arr.indexOf(val);
                }

                var len
                    , i;

                if (arr &amp;&amp; (len = arr.length)) {
                    i = 0;
                    //possible todo: faster and more efficient loop
                    for (; i &lt; len; i++) {
                        if (arr[i] === val) {
                            return i;
                        }
                    }
                }

                return -1;
            }
        };
    }

    //I want to make sure this is a number
    function _isRealNum(value) {
        return typeof value === 'number' &amp;&amp; !isNaN(value);
    }

    function _bInsert(arr, val) {
        var leftIdx = 0,
            rightIdx = arr.length,
            midIdx,
            midVal;

        if (!rightIdx ||
            (
                (rightIdx = rightIdx - 1) &amp;&amp; arr[rightIdx] &lt; val
            )
        ) {
            arr.push(val);
            return rightIdx;
        }

        if (arr[leftIdx] > val) {
            arr.unshift(val);
            return leftIdx;
        }

        while (leftIdx &lt;= rightIdx) {
            midIdx = Math.floor((leftIdx + rightIdx) / 2);
            midVal = arr[midIdx];

            if (midVal > val) {
                rightIdx = midIdx - 1;
                continue;
            }

            leftIdx = midIdx + 1;
            if (midVal === val) {
                return;
            }

        }
        arr.splice(leftIdx, 0, val);
        return leftIdx;
    }

    /**
     * @private
     * @desc private console output. Currently logs by default.
     * @todo: think of good way to toggle logging.
     */
    function _debugLog() {
        /* global console */
        var args;
        if (PrioritizedPubSub.isLogged) {
            args = util.toArray(arguments);
            args.unshift('PSP: ');

            _debugLog.log(args);
        }
    }

    if (global &amp;&amp; global.console) { //IE &lt;= 8 fix
        _debugLog.log = function (args) {
            try {
                global.console.log.apply(window.console, args);
            } catch (e) {
                global.console.log(args);
            }
        };
    } else {
        _debugLog.log = function (args) {
            try {
                console.log.apply(console, args);
            } catch (e) {
                console.log(args);
            }
        };
    }

    /**
     * Where all subscribers and priorities are kept.
     * @private
     * @class Subscriptions
     * @param eventName
     * @param pspName
     * @constructor
     */
    function Subscriptions(eventName, pspName) {
        var i = 0,
            timings = {},
            type;

        while(type = PRIORITY_TYPE[i++]){

            //there can be only one default and it's set to null until def is set to a function.
            if (type === 'def') {
                timings[type] = null;
                continue;
            }
            
            timings[type] = {
               'table' :{}, 
               'list' : []
            };
        }
        /*
         keeps all the subscriber data, i.e. options.sub and other future config
         Example data structure:
         this.subIds = {
             "sub id 1" : {
                 "subId" : "sub id 1",
                 "timing" : "pre",
                 "priority": 0,
                 "sub" : function () {[code]},
                 ...
             },
             "sub id 2" : {
                 "subId" : "sub id 2",
                 "timing" : "post",
                 "priority": 11,
                 "sub" : function () {[code]},
                 ...
             },
             "pr-120334234" : {
                 "subId" : "pr-120334234",
                 "timing" : "def",
                 "priority": 2,
                 "sub" : function () {[code]},
                ...
             },
             "sub id 3" : {
                 "subId" : "sub id 3",
                 "timing" : "pre",
                 "priority": 5,
                 "sub" : function () {[code]},
                 ...
             },
             "sub id 4" : {
                 "subId" : "sub id 4",
                 "timing" : "pre",
                 "priority": 5,
                 "sub" : function () {[code]},
                 ...
             },
            ...
         }
         Possible todo is to remove extra data that isn't used from the config.
         */
        this.subIds = {};
        //used for subscribers to know if data has been published and needs to be re-published.
        this.hasPub = false;
        //if publication happens, oldArgs is kept for future subscribers that want to use past published data.
        this.oldArgs = {};
        /*
         Example data structure:
         this.timings = {
             "pre" :{
                 "list":[
                     -5
                     0,
                     5
                 ],
                 "table":{
                    -5:[
                        "more sub ids"
                    ],
                    0: [
                        "sub id 1"
                    ],
                    5:[
                         "sub id 4",
                         "sub id 5"
                    ]
                 }
             },
             "def" : "pr-120334234",
             "post" :{
                 "list":[
                    -99,
                    17,
                    11,
                    100
                 ],
                 "table":{
                     -99:[
                        "another sub id"
                     ],
                     17: [
                        "sub id 33"
                     ],
                     11:[
                         "sub id 12",
                         "sub id 99"
                     ],
                     100:[
                        "sub something"
                     ]
                 }
             }
         }
        */
        this.timings = timings;
        //for console.log
        this.eventName = pspName + eventName + '-> ';
    }

    Subscriptions.prototype = {
        'constructor': Subscriptions,
        /**
         * Updates or adds subscriber id with new definition.
         * @param {Object} config
         */
        'replaceSubId': function (config) {
            var timing = this.timings[config.timing],
                priority;

            this.removeSubId(config.subId, false);

            this.subIds[config.subId] = config;

            if (config.timing === 'def') {

                this.removeSubId(timing);
                this.timings[config.timing] = config.subId;
                return;
            }

            priority = timing[config.priority];

            //list of priorities is only set to an array until it needs it.
            if (util.isUndefined(priority)) {
                priority = timing[config.priority] = [];
            }
            //all new subId are added to the end of the priority list
            priority.push(config.subId);
        },
        /**
         * Find and remove subId from list of priorities.
         * If untrack is true or undefined, then delete from list of subIds
         * @param {String} subId
         * @param {undefined|Boolean} [untrack=undefined]
         * @returns {Boolean}
         */
        'removeSubId': function (subId, untrack) {
            var subIdData,
                indexOf,
                priority,
                timing;

            if (
                util.isString(subId)
                &amp;&amp; (subIdData = this.subIds[subId])
                &amp;&amp; util.isObject(subIdData)
            ) {

                timing = this.timings[subIdData.timing];

                if (util.isString(timing)) {

                    _debugLog(this.eventName + 'removing default timing');
                    this.timings[subIdData.timing] = null;

                } else if (
                    timing
                    &amp;&amp; timing.length
                    &amp;&amp; (priority = timing[subIdData.priority])
                    &amp;&amp; priority.length
                    &amp;&amp; (indexOf = util.indexOf(priority, subId)) >= 0
                ) {
                    priority.splice(indexOf, 1);
                }

                if (util.isUndefined(untrack) || untrack === true) {
                    delete this.subIds[subId];
                    _debugLog(this.eventName + ' is completely erasing ' + subId);
                }

                return true;
            }

            _debugLog(this.eventName + ' had nothing to remove for ' + subId);
            return false;
        },
        'publishToSubscriber': function (subId, data) {
            var subIdData,
                isCount,
                result;

            data = data || this.oldArgs;

            if (
                util.isString(subId)
                &amp;&amp; (subIdData = this.subIds[subId])
                &amp;&amp; util.isFunction(subIdData.sub)
            ) {
                isCount = _isRealNum(subIdData.unPubCount);

                if (
                    !isCount
                    || (
                        isCount
                        &amp;&amp; subIdData.unPubCount > 0
                    )
                ) {
                    try {
                        result = subIdData.sub.apply(
                            subIdData.context
                            , [
                                data
                                , {
                                    'CONST': {
                                        'SKIP_DEC': SKIP_DEC
                                      , 'UNSUB': UNSUB
                                    }
                                }
                            ]
                        );
                    } catch (e) {
                        _debugLog(e);
                    }
                }

                if (
                    result === UNSUB
                    || (
                        result !== SKIP_DEC
                        &amp;&amp; isCount
                        &amp;&amp; --subIdData.unPubCount &lt;= 0
                    )
                ) {
                    _debugLog(this.eventName + 'Subscriber subId ' + subId + ' removed itself. Result:', result);
                    this.removeSubId(subId);
                    return false;
                }

                return true;
            }
            return null;
        },
        'publish': function (args) {
            var tidx = 0,
                timing,
                pidx,
                priorities,
                priority,
                sidx,
                subId,
                result;

            //Clone?
            this.oldArgs = args;
            this.hasPub = true;

            for (timing = PRIORITY_TYPE[tidx]; tidx &lt; PRIORITY_TYPE.length; timing = PRIORITY_TYPE[++tidx]) {
                priorities = this.timings[timing];

                if (timing === 'def' &amp;&amp; util.isString(priorities)) {

                    //Default should be the only one that matches this
                    _debugLog(this.eventName + 'Publishing to default');
                    this.publishToSubscriber(priorities, args);

                } else if (priorities &amp;&amp; priorities.length) {

                    for (pidx = priorities.length - 1, priority = priorities[pidx]; pidx >= 0; priority = priorities[--pidx]) {

                        if (priority &amp;&amp; priority.length) {
                            sidx = 0;
                            while ((subId = priority[sidx])) {

                                _debugLog(
                                    this.eventName + 'Publishing subId ' + subId + ' TIMING ' + timing
                                    + ' PRIORITY ' + pidx
                                );

                                switch ((result = this.publishToSubscriber(subId, args))) {
                                    case false:
                                        //if false returned, then the subscription was removed
                                        // and the current index is still relevant.
                                        break;
                                    default:
                                        sidx++;
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
    };

    /**
     * @private
     * @class PSP
     * @constructor
     * @param {String} PSPName name to use to identify what PSP is firing for console log.
     */
    function PSP(PSPName) {
        this.pspName = '';
        /*
         keeps track of all event names that have subscriptions.
         Example data structure
         this.subList = {
            "myGlobalEvent" : Subscriptions,
            "myOtherEvent": Subscriptions
         };
         */
        this.subList = {};

        if (util.isString(PSPName)) {
            this.pspName += PSPName;
        } else {
            this.pspName += 'PSP' + Math.ceil(Math.random() * 10000000);
        }

        this.pspName += '::';
    }

    PSP.prototype = {
        'constructor': PSP,

        /**
         * @param {String} eventName
         * @param {Object} [args]
         */
        'pub': function (eventName, args) {
            args = util.isObject(args) ? args : {};

            var event = this.getSub(eventName);

            if (event) {
                event.publish(args);
            }
        },

        /**
         *
         * @param {String} eventName
         * @param {Object|Function|subscriptionOptions} config
         * @returns {Boolean|null}
         */
        'sub': function (eventName, config) {
            var event,
                configType = typeof config,
                isFunction = (configType === 'function'),
                temp;

            if (
                config
                &amp;&amp; (configType === 'object' || isFunction)
            ) {

                if (isFunction) {
                    config = {
                        'sub': config
                    };
                }

                event = this.getSub(eventName);

                //create random id if subId is defined for config tracking.
                if (!util.isString(config.subId)) {
                    config.subId = 'pr-' + Math.ceil(Math.random() * 10000000);
                }

                temp = parseInt(config.priority, 10);
                if (!_isRealNum(temp)) {
                    temp = 0;
                }

                config.priority = temp;

                temp = util.indexOf(PRIORITY_TYPE, config.timing);

                if (temp &lt; 0) {
                    temp = PRIORITY_TYPE[0]; //default config timing is pre
                } else {
                    temp = PRIORITY_TYPE[temp];
                }

                config.timing = temp;

                event.replaceSubId(config);

                if (config.rePub &amp;&amp; event.hasPub) {
                    _debugLog(this.pspName + eventName + ' event was published. Re-publish subId ' + config.subId);
                    event.publishToSubscriber(config.subId);
                }

                return true;
            }

            _debugLog(this.pspName + eventName + ' was not given a legitimate config');

            return null;
        },

        /**
         *
         * @param {String} eventName
         * @param {String} subId
         */
        'unSub': function (eventName, subId) {
            var event = this.getSub(eventName);

            if (event) {
                _debugLog(this.pspName + 'un-subscribing subId ' + subId + ' from ' + eventName);
                event.removeSubId(subId);
            }
        },

        /**
         * Return or create new Subscription.
         * @private
         * @param  {String} subName
         * @return {Subscriptions}
         */
        'getSub': function (subName) {
            var event = this.subList[subName];

            if (!event) {
                _debugLog(this.pspName + 'Creating new subscription: ' + subName);
                this.subList[subName] = event = new Subscriptions(subName, this.pspName);
            }

            return event;
        },

        /**
         * Determines what type of action to do based on what the options are.
         * @param {String}                              eventName
         * @param {Object|Function|subscriptionOptions} options
         */
        'exec': function (eventName, options) {
            var optionsType,
                isObj;

            options = options || {};

            if (options &amp;&amp; util.isString(eventName)) {
                isObj = (optionsType = typeof options) === 'object';
                //subscribe using default config
                if (
                    optionsType === 'function'
                    || (
                        isObj
                        &amp;&amp; util.isFunction(options.sub)
                    )
                ) {
                    if (this.sub(eventName, options) === null) {
                        _debugLog(this.pspName + 'Subscription definition was invalid and was not registered');
                    }
                } else if (isObj) {
                    if (util.isString(options.unSub)) {
                        this.unSub(eventName, options.unSub);
                    } else { //publish to eventName
                        options = options.pub || options;
                        this.pub(eventName, options);
                    }
                }
            }
        }
    };

    /**
     * @param   {String} pspNamespace
     * @returns {publicPSP}
     */
    function PSPProxy(pspNamespace) {
        var _PSP = new PSP(pspNamespace);

        function publicPSP() {
            _PSP.exec.apply(
                _PSP
              , util.toArray(arguments)
            );
        }

        publicPSP.pub = function () {
            _PSP.pub.apply(_PSP, util.toArray(arguments));
            return this;
        };

        publicPSP.sub = function () {
            _PSP.sub.apply(_PSP, util.toArray(arguments));
            return this;
        };

        publicPSP.unSub = function () {
            _PSP.unSub.apply(_PSP, util.toArray(arguments));
            return this;
        };

        publicPSP.getEventPubCallback = function (eventName) {

            return function (args) {
                publicPSP.pub(eventName, args);
            };
        };

        publicPSP.getEventProxy = function (eventName) {

            return {
                'pub': function (args) {
                    publicPSP.pub(eventName, args);
                    return this;
                },
                'sub': function (options) {
                    publicPSP.sub(eventName, options);
                    return this;
                },
                'unSub': function (subId) {
                    publicPSP.unSub(eventName, subId);
                    return this;
                }
            };
        };

        return publicPSP;
    }

    _globalPSP = new PSPProxy('GLOBAL');

    function PrioritizedPubSub(subNameSpace) {
        /* global window */
        if (util.isUndefined(this) || this === window) {

            _globalPSP.apply(
                _globalPSP,
                util.toArray(arguments)
            );

            return PrioritizedPubSub;

        } else if (util.isString(subNameSpace)) {
            //return new proxy
            return new PSPProxy(subNameSpace);
        }
    }

    /**
     * @static
     * @memberOf PrioritizedPubSub
     * @function
     * @param   {eventName}                                 eventName
     * @param   {subscriptionOptions|subscriptionCallback}  options
     * @returns {PrioritizedPubSub}
     */
    PrioritizedPubSub.sub = _globalPSP.sub;

    /**
     * @static
     * @function
     * @memberOf PrioritizedPubSub
     * @param   {eventName} eventName
     * @param   {Object}    [options]
     * @returns {PrioritizedPubSub}
     */
    PrioritizedPubSub.pub = _globalPSP.pub;

    /**
     * @static
     * @function
     * @memberOf PrioritizedPubSub
     * @param {eventName}       eventName
     * @param {subscriptionId}  subId
     * @returns {PrioritizedPubSub}
     */
    PrioritizedPubSub.unSub = _globalPSP.unSub;

    /**
     * Returns a function for use in publishing to an event
     * @example
     *
     *  var pspCb = PrioritizedPubSub.getEventPubCallback('myEvent');
     *
     *  pspCb({arg1:1, arg2: 2});
     *
     *  //same as but you can keep re-using the call back instead of do this over and over.
     *
     *  PrioritizedPubSub('myEvent', {pub:{arg1:1, arg2: 2}});
     *
     * @static
     * @function
     * @memberOf PrioritizedPubSub
     * @param {eventName}   eventName
     * @returns {Function}
     */
    PrioritizedPubSub.getEventPubCallback = _globalPSP.getEventPubCallback;

    /**
     * Get an object with proxy functions for re-use.
     * @example
     *
     *  var pspEventProxy = PrioritizedPubSub.getEventProxy('myEvent');
     *
     *  // Same as PrioritizedPubSub('myEvent', {pub:{arg1:1, arg2: 2}});
     *
     *  pspEventProxy.pub({arg1:1, arg2: 2});
     *
     *  // Same as PrioritizedPubSub('myEvent', function () { //do stuff });
     *
     *  pspEventProxy.sub(function () { //do stuff });
     *
     *  // Same as PrioritizedPubSub('myEvent', {unSub:'something'}});
     *
     *  pspEventProxy.unSub('something');
     *
     * @static
     * @function
     * @memberOf PrioritizedPubSub
     * @param {eventName} eventName
     * @returns {
     *      {
     *          pub: Function,
     *          sub: Function,
     *          unSub: Function
     *      }
     *  }
     */
    PrioritizedPubSub.getEventProxy = _globalPSP.getEventProxy;

    PrioritizedPubSub.isLogged = true;

    return PrioritizedPubSub;
}));

</code></pre>
        </article>
    </section>






        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a> on Fri May 15 2015 05:41:07 GMT+0000 (UTC)
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/main.js"></script>
</body>
</html>
