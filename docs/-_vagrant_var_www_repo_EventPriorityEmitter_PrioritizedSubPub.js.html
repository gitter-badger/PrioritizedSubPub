<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Source: /vagrant/var/www/repo/EventPriorityEmitter/PrioritizedSubPub.js</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jaguar.css">
    
    
    <script>
    var config = {"monospaceLinks":false,"cleverLinks":false,"applicationName":"PrioritizedSubPub","linenums":true,"default":{"outputSourceFiles":true}};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">PrioritizedSubPub</a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentations">
    </div>
    <ul class="list">
    
        <li class="item" data-name="PrioritizedPubSub">
            <span class="title">
                <a href="PrioritizedPubSub.html">PrioritizedPubSub</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="PrioritizedPubSub.getEventProxy"><a href="PrioritizedPubSub.html#.getEventProxy">getEventProxy</a></li>
            
                <li data-name="PrioritizedPubSub.getEventPubCallback"><a href="PrioritizedPubSub.html#.getEventPubCallback">getEventPubCallback</a></li>
            
                <li data-name="PrioritizedPubSub.pub"><a href="PrioritizedPubSub.html#.pub">pub</a></li>
            
                <li data-name="PrioritizedPubSub.sub"><a href="PrioritizedPubSub.html#.sub">sub</a></li>
            
                <li data-name="PrioritizedPubSub.unSub"><a href="PrioritizedPubSub.html#.unSub">unSub</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
    </ul>
</div>
    <div class="main">
        <h1 class="page-title" data-filename="-_vagrant_var_www_repo_EventPriorityEmitter_PrioritizedSubPub.js.html">Source: /vagrant/var/www/repo/EventPriorityEmitter/PrioritizedSubPub.js</h1>
        


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * PrioritizedPubSub
 * @class PrioritizedPubSub
 * @param   {String}                                        subNameSpace
 * @param   {subscriptionOptions|subscriptionCallback}      [options]
 * @returns {PrioritizedPubSub|PSPProxy}
 */

/**
 * Event name used for subscribing/publishing to.
 * @typedef {String} eventName
 */

/**
 * User-defined id for identifying and removing from priority list. Randomly generated if not defined when
 * subscribing.
 * @typedef {String} subscriptionId
 */

/**
 * @typedef {Object} subscriptionOptions
 *
 * @property {subscriptionCallback}                         Required for subscribing to an event. See {@see subscriptionCallback}
 *
 *
 * @property {Integer}  [subscriptionCallback.unSubCount]   Will subscribe to however many times set. When it reaches the
 *                                                          limit, it will un-subscribe itself. Decrementing can be bypassed.
 *                                                          See {@see pspObj}
 *
 * @property {Boolean}  [subscriptionCallback.rePub]        If set to true and subscribing to an event and the event had
*                                                           published in the past, then re-publish for this subscriber
 *                                                          using the previously publish data.
 *
 * @property {String}   [subscriptionCallback.subId]        {@see subscriptionId}
 *
 * @property {Integer}  [subscriptionCallback.priority]      0-11 where 0 is the lowest (last subscriber to get published data) priority
 *                                                           and 11 is the highest (first subscriber to get published data).
 *                                                           Every subscription will append to the list of priorities,
 *                                                           except for subscriptionOptions.timing="def" since there
 *                                                           can be only one default.
 *                                                           If subscribing and options.priority is not set, 6 is used.
 *                                                           This is ignored when subscriptionOptions.timing="def".
 *
 * @property {String}   [subscriptionCallback.timing]        See {@see subscriptionTimings}
 *
 * @property {*}        [subscriptionCallback.context]       Specify the context of `this`
 */

/**
 * When the priority should happen. If not set during subscribing, pre will be used.
 * @typedef {String} subscriptionTimings
 * @desc pre    Before default timing. There can be many of these timings.
 * @desc def    Default publish event. There is only one default timing.
 * @desc post   After default event. There can be many of these timings.
 */

/**
 * Object passed to {@see subscriptionCallback}.
 * @typedef {Object} pspObj
 * @property {Object} pspObj.CONST
 * @property {String} pspObj.CONST.SKIP_DEC      Prevent the subscriptionOptions.unSubCount from decrementing
 * @property {String} pspObj.CONST.UNSUB         Used to un-subscribe subscriptionCallback
 */

/**
 * This callback type is called `subscriptionCallback`.
 *
 * @callback subscriptionCallback
 * @param {Object}  args
 * @param {pspObj}
 */
(function (root, factory) {
    'use strict';
    /* global define, module */
    var ns = 'PrioritizedSubPub';
    //boilerplate node and browser defining.
    if (typeof define === 'function' &amp;&amp; define.amd) {
        define(ns, factory(root));
    } else if (
           typeof module === 'object'
        &amp;&amp; typeof module.exports === 'object'
    ) {
        module.exports = factory(root);
    } else {
        root[ns] = factory(root);
    }

} (this, function () {
    'use strict';

    var PRIORITY_TYPE = ['pre', 'def', 'post']
      , PRIORITY_LIMIT = 11
      , UNSUB = 'unsub'
      , SKIP_DEC = 'skip_dec'
      , util
        //host global usage for PSP
      , _globalPSP
      ;

    /* jshint ignore: start */
    if ( (_globalPSP = typeof _)
      &amp;&amp; _globalPSP === 'function'
    ) {
        util = _;
    }
    /* jshint ignore: end */

    if (typeof util === 'undefined') {
        //Mini lodash/underscore
        util = {
            isUndefined: function (value) { return typeof value === 'undefined'; }
          , isObject: function (value) { return value &amp;&amp; typeof value === 'object'; }
          , isString: function (value) { return typeof value === 'string'; }
          , isFunction: function (value) { return typeof value === 'function'; }
          , toArray: function (args) { return Array.prototype.slice.call(args);}
          , indexOf: function (arr, val) {
                if (arr.indexOf) {
                    return arr.indexOf(val);
                }

                var len
                  , i;

                if (arr &amp;&amp; (len = arr.length)){
                    i = 0;
                    //possible todo: faster and more efficient loop
                    for (; i &lt; len; i++) {
                        if (arr[i] === val) {
                            return i;
                        }
                    }
                }

                return -1;
            }
        };
    }

    //I want to make sure this is a number
    if (!util.isFunction(util.isRealNumber)) {
        util.isRealNumber = function (value) { return typeof value === 'number' &amp;&amp; !isNaN(value); };
    }

    /**
     * @private
     * @desc private console output. Currently logs by default.
     * @todo: think of good way to toggle logging.
     */
     function _debugLog() {
        /* global console */
        var args,
            log;
        if (PrioritizedPubSub.isLogged &amp;&amp; console &amp;&amp; (log = console.log)) {
            args = util.toArray(arguments);
            args.unshift('PSP: ');
            try{
                log.apply(console, args);
            } catch(e) {
                log(args);
            }
        }
    }

    /**
     * Makes sure value is within range.
     * @private
     * @param validate
     * @param max
     * @param [min=0]
     * @returns {boolean}
     */
    function _isValidRange(validate, max, min) {
        min = min || 0;

        return util.isRealNumber(validate) &amp;&amp; validate >= min &amp;&amp; validate &lt;= max;
    }

    /**
     * Where all subscribers and priorities are kept.
     * @private
     * @class Subscriptions
     * @param eventName
     * @param pspName
     * @constructor
     */
    function Subscriptions(eventName, pspName){
        var i = 0,
            timings = {},
            type;

        for(type = PRIORITY_TYPE[i]; i &lt; PRIORITY_TYPE.length; type = PRIORITY_TYPE[++i]){

            //there can be only one default and it's set to null until def is set to a function.
            if (type === 'def') {
                timings[type] = null;
                continue;
            }
            //TODO: use a wrapped array for unrestricted priority numbers
            timings[type] = [];
        }
        /*
            keeps all the subscriber data, i.e. options.sub and other future config
            Example data structure:
            this.subIds = {
               "sub id 1" : {
                    "subId" : "sub id 1",
                    "timing" : "pre",
                    "priority": 0,
                    "sub" : function () {[code]},
                    ...
               },
               "sub id 2" : {
                    "subId" : "sub id 2",
                    "timing" : "post",
                    "priority": 11,
                    "sub" : function () {[code]},
                    ...
               },
               "pr-120334234" : {
                    "subId" : "pr-120334234",
                    "timing" : "def",
                    "priority": 2,
                    "sub" : function () {[code]},
                    ...
               },
               "sub id 3" : {
                    "subId" : "sub id 3",
                    "timing" : "pre",
                    "priority": 5,
                    "sub" : function () {[code]},
                    ...
               },
               "sub id 4" : {
                    "subId" : "sub id 4",
                    "timing" : "pre",
                    "priority": 5,
                    "sub" : function () {[code]},
                    ...
               },
               ...
            }
            Possible todo is to remove extra data that isn't used from the config.
         */
        this.subIds = {};
        //used for subscribers to know if data has been published and needs to be re-published.
        this.hasPub = false;
        //if publication happens, oldArgs is kept for future subscribers that want to use past published data.
        this.oldArgs = {};
        /* 
            pre and post will be an array with length PRIORITY_LIMIT of arrays of unlimited size
            containing subIds.
            Example data structure:
            this.timings = {
                "pre" : [
                    [ // index = 0
                        "sub id 1"
                    ],
                    undefined,
                    ...
                    [ // index = 5
                        "sub id 4",
                        "sub id 5"
                    ]
                ],
                "def" : "pr-120334234",
                "post" : [
                    undefined, // index = 0
                    ...
                    [ // index = 11
                        "sub id 3"
                    ]
                ]
            }
         */
        this.timings = timings;
        //for console.log
        this.eventName = pspName + eventName + '-> ';
    }

    Subscriptions.prototype = {
        'constructor': Subscriptions,
        /**
         * Updates or adds subscriber id with new definition.
         * @private
         * @param {Object} config
         */
        'replaceSubId' : function (config) {
            var timing = this.timings[config.timing],
                priority;

            this.removeSubId(config.subId, false);

            this.subIds[config.subId] = config;

            if (config.timing === 'def') {

                this.removeSubId(timing);
                this.timings[config.timing] = config.subId;

            } else {
                
                priority = timing[config.priority];

                //list of priorities is only set to an array until it needs it.
                if (util.isUndefined(priority)) {
                    priority = timing[config.priority] = [];
                }
                //all new subId are added to the end of the priority list
                priority.push(config.subId);
            }
        },
        /**
         * Find and remove subId from list of priorities. 
         * If untrack is true or undefined, then delete from list of subIds  
         * @private
         * @param {String} subId
         * @param {undefined|Boolean} [untrack=undefined]
         * @returns {Boolean}
         */
        'removeSubId': function (subId, untrack) {
            var subIdData,
                indexOf,
                priority,
                timing;

            if (
                   util.isString(subId)
                &amp;&amp; (subIdData = this.subIds[subId])
                &amp;&amp; util.isObject(subIdData)
            ) {

                timing = this.timings[subIdData.timing];

                if (util.isString(timing)) {

                    _debugLog(this.eventName + 'removing default timing');
                    this.timings[subIdData.timing] = null;

                } else if (
                       timing
                    &amp;&amp; timing.length
                    &amp;&amp; (priority = timing[subIdData.priority])
                    &amp;&amp; priority.length
                    &amp;&amp; (indexOf = util.indexOf(priority, subId)) >= 0
                ){
                    priority.splice(indexOf, 1);
                }

                if (util.isUndefined(untrack) || untrack === true) {
                    delete this.subIds[subId];
                    _debugLog(this.eventName + ' is completely erasing ' + subId);
                }

                return true;
            }

            _debugLog(this.eventName + ' had nothing to remove for ' + subId);
            return false;
        },
        'publishToSubscriber': function (subId, data) {
            var subIdData,
                isCount,
                result;

            data = data || this.oldArgs;
            
            if (
                   util.isString(subId)
                &amp;&amp; (subIdData  = this.subIds[subId])
                &amp;&amp; util.isFunction(subIdData.sub)
            ) {
                isCount = util.isRealNumber(subIdData.unPubCount);

                if (
                       !isCount
                    || (
                           isCount
                        &amp;&amp; subIdData.unPubCount > 0
                    )
                ) {
                    try {
                        result = subIdData.sub.apply(
                            subIdData.context
                            , [
                                data
                                , {
                                    'CONST': {
                                        'SKIP_DEC': SKIP_DEC
                                        , 'UNSUB': UNSUB
                                    }
                                }
                            ]
                        );
                    } catch(e) {
                        _debugLog(e);
                    }
                }

                if (
                    result === UNSUB
                    || (
                           result !== SKIP_DEC
                        &amp;&amp; isCount
                        &amp;&amp; --subIdData.unPubCount &lt;= 0
                    )
                ) {
                    _debugLog(this.eventName + 'Subscriber subId ' + subId + ' removed itself. Result:', result);
                    this.removeSubId(subId);
                    return false;
                }

                return true;
            }
            return null;
        },
        'publish': function (args) {
            var tidx = 0,
                timing,
                pidx,
                priorities,
                priority,
                sidx,
                subId,
                result;

            //Clone?
            this.oldArgs = args;
            this.hasPub = true;

            for (timing = PRIORITY_TYPE[tidx]; tidx &lt; PRIORITY_TYPE.length; timing = PRIORITY_TYPE[++tidx]) {
                priorities = this.timings[timing];

                if (timing === 'def' &amp;&amp; util.isString(priorities)) {

                    //Default should be the only one that matches this
                    _debugLog(this.eventName + 'Publishing to default');
                    this.publishToSubscriber(priorities, args);

                } else if (priorities &amp;&amp; priorities.length) {

                    for (pidx = priorities.length - 1, priority = priorities[pidx]; pidx >= 0; priority = priorities[--pidx]) {

                        if (priority &amp;&amp; priority.length) {
                            sidx = 0;
                            while((subId = priority[sidx])) {

                                _debugLog(
                                    this.eventName + 'Publishing subId ' + subId + ' TIMING ' + timing
                                  + ' PRIORITY ' + pidx
                                );
                                
                                switch ((result = this.publishToSubscriber(subId, args))) {
                                    case false:
                                    //if false returned, then the subscription was removed
                                    // and the current index is still relevant.
                                    break;
                                    default:
                                        sidx++;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    };

    /**
     * @private
     * @class PSP
     * @constructor
     * @param {String} PSPName name to use to identify what PSP is firing for console log.
     */
    function PSP(PSPName) {
        this.pspName = '';
        /*
            keeps track of all event names that have subscriptions.
            Example data structure
            this.subList = {
                "myGlobalEvent" : Subscriptions,
                "myOtherEvent": Subscriptions
            };
         */
        this.subList = {};

        if (util.isString(PSPName)) {
            this.pspName += PSPName;
        } else {
            this.pspName += 'PSP' + Math.ceil(Math.random() * 10000000);
        }

        this.pspName += '::';
    }

    PSP.prototype = {
        'constructor' : PSP,

        /**
         * @param {String} eventName
         * @param {Object} [args]
         */
        'pub': function (eventName, args) {
            args = util.isObject(args) ? args : {};

            var event = this.getSub(eventName);

            if (event) {
                event.publish(args);
            }
        },

        /**
         *
         * @param {String} eventName
         * @param {Object|Function} config
         * @returns {Boolean|null}
         */
        'sub': function (eventName, config) {
            var event,
                configType = typeof config,
                isFunction = (configType === 'function'),
                temp;

            if (
                   config
                &amp;&amp; (configType === 'object' || isFunction)
            ) {

                if (isFunction) {
                    config = {
                        'sub' : config
                    };
                }

                event = this.getSub(eventName);

                //create random id if subId is defined for config tracking.
                if (!util.isString(config.subId)) {
                    config.subId = 'pr-' + Math.ceil(Math.random() * 10000000);
                }

                temp = parseInt(config.priority, 10);
                if (!_isValidRange(temp, PRIORITY_LIMIT)) {
                    temp = Math.round(PRIORITY_LIMIT / 2);
                }

                config.priority = temp;

                temp = util.indexOf(PRIORITY_TYPE, config.timing);

                if(temp &lt; 0) {
                    temp = PRIORITY_TYPE[0]; //default config timing is pre
                } else {
                    temp = PRIORITY_TYPE[temp];
                }

                config.timing = temp;

                event.replaceSubId(config);

                if(config.rePub &amp;&amp; event.hasPub) {
                    _debugLog(this.pspName + eventName + ' event was published. Re-publish subId ' + config.subId);
                    event.publishToSubscriber(config.subId);
                }

                return true;
            }

            _debugLog(this.pspName + eventName + ' was not given a legitimate config');

            return null;
        },

        /**
         *
         * @param {String} eventName
         * @param {String} subId
         */
        'unSub': function (eventName, subId) {
            var event = this.getSub(eventName);

            if (event) {
                _debugLog(this.pspName + 'un-subscribing subId ' + subId + ' from ' + eventName);
                event.removeSubId(subId);
            }
        },

        /**
         * Return or create new Subscription.
         * @param  {String} subName
         * @return {Subscriptions}
         * @private
         */
        'getSub': function (subName) {
            var event = this.subList[subName];

            if (!event) {
                _debugLog(this.pspName + 'Creating new subscription: ' + subName);
                this.subList[subName] = event = new Subscriptions(subName, this.pspName);
            }

            return event;
        },

        /**
         * Determines what type of action to do based on what the options are.
         * @param  {String} eventName
         * @param  {Object|Function} options
         */
        'exec': function(eventName, options) {
            var optionsType,
                isObj;

            options = options || {};

            if (options &amp;&amp; util.isString(eventName)) {
                isObj = (optionsType = typeof options) === 'object';
                //subscribe using default config
                if (
                    optionsType === 'function'
                    || (
                           isObj
                        &amp;&amp; util.isFunction(options.sub)
                    )
                ) {
                    if(this.sub(eventName, options) === null) {
                        _debugLog(this.pspName + 'Subscription definition was invalid and was not registered');
                    }
                } else if (isObj) {
                    if (util.isString(options.unSub)) {
                        this.unSub(eventName, options.unSub);
                    } else { //publish to eventName
                        options = options.pub || options;
                        this.pub(eventName, options);
                    }
                }
            }
        }
    };

    /**
     * @param   {String} pspNamespace
     * @returns {publicPSP}
     */
    function PSPProxy(pspNamespace) {
        var _PSP = new PSP(pspNamespace);

        function publicPSP() {
            _PSP.exec.apply(
                _PSP
              , util.toArray(arguments)
            );
        }

        publicPSP.pub = function () { _PSP.pub.apply(_PSP, util.toArray(arguments)); return this; };

        publicPSP.sub = function () { _PSP.sub.apply(_PSP, util.toArray(arguments)); return this; };

        publicPSP.unSub = function () { _PSP.unSub.apply(_PSP, util.toArray(arguments)); return this; };

        publicPSP.getEventPubCallback = function (eventName) {

            return function (args) {
                publicPSP.pub(eventName, args);
            };
        };

        publicPSP.getEventProxy = function (eventName) {

            return {
                'pub': function (args) {
                    publicPSP.pub(eventName, args);
                    return this;
                },
                'sub': function (options) {
                    publicPSP.sub(eventName, options);
                    return this;
                },
                'unSub': function (subId) {
                    publicPSP.unSub(eventName, subId);
                    return this;
                }
            };
        };

        return publicPSP;
    }

    _globalPSP = new PSPProxy('GLOBAL');

    function PrioritizedPubSub(subNameSpace) {
        /* global window */
        if (util.isUndefined(this) || this === window) {

            _globalPSP.apply(
                _globalPSP,
                util.toArray(arguments)
            );

            return PrioritizedPubSub;

        } else if (util.isString(subNameSpace)) {
            //return new proxy
            return new PSPProxy(subNameSpace);
        }
    }

    /**
     * @static
     * @memberOf PrioritizedPubSub
     * @function
     * @param   {eventName}                                 eventName
     * @param   {subscriptionOptions|subscriptionCallback}  options
     * @returns {PrioritizedPubSub}
     */
    PrioritizedPubSub.sub = _globalPSP.sub;

    /**
     * @static
     * @function
     * @memberOf PrioritizedPubSub
     * @param   {eventName} eventName
     * @param   {Object}    [options]
     * @returns {PrioritizedPubSub}
     */
    PrioritizedPubSub.pub = _globalPSP.pub;

    /**
     * @static
     * @function
     * @memberOf PrioritizedPubSub
     * @param {eventName}       eventName
     * @param {subscriptionId}  subId
     * @returns {publicPSP}
     */
    PrioritizedPubSub.unSub = _globalPSP.unSub;

    /**
     * Returns a function for use in publishing to an event
     * @example
     *
     *  var pspCb = PrioritizedPubSub.getEventPubCallback('myEvent');
     *
     *  pspCb({arg1:1, arg2: 2});
     *
     *  //same as but you can keep re-using the call back instead of do this over and over.
     *
     *  PrioritizedPubSub('myEvent', {pub:{arg1:1, arg2: 2}});
     *
     * @static
     * @function
     * @memberOf PrioritizedPubSub
     * @param {eventName}   eventName
     * @returns {Function}
     */
    PrioritizedPubSub.getEventPubCallback = _globalPSP.getEventPubCallback;

    /**
     * Get an object with proxied functions for re-use.
     * @example
     *
     *  var pspEventProxy = PrioritizedPubSub.getEventProxy('myEvent');
     *
     *  // Same as PrioritizedPubSub('myEvent', {pub:{arg1:1, arg2: 2}});
     *
     *  pspEventProxy.pub({arg1:1, arg2: 2});
     *
     *  // Same as PrioritizedPubSub('myEvent', function () { //do stuff });
     *
     *  pspEventProxy.sub(function () { //do stuff });
     *
     *  // Same as PrioritizedPubSub('myEvent', {unSub:'something'}});
     *
     *  pspEventProxy.unSub('something');
     *
     * @static
     * @function
     * @memberOf PrioritizedPubSub
     * @param {eventName} eventName
     * @returns {
     *      {
     *          pub: Function,
     *          sub: Function,
     *          unSub: Function
     *      }
     *  }
     */
    PrioritizedPubSub.getEventProxy = _globalPSP.getEventProxy;

    PrioritizedPubSub.isLogged = true;

    return PrioritizedPubSub;
}));

</code></pre>
        </article>
    </section>






        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-beta2</a> on Mon Apr 27 2015 02:40:10 GMT+0000 (UTC)
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/main.js"></script>
</body>
</html>
